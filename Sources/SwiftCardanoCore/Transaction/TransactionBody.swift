import Foundation
import SwiftNcal
import PotentCBOR
import OrderedCollections

public struct TransactionBody: Serializable, TextEnvelopable, Equatable {

    public static var TYPE: String { "Unsigned TxBody ConwayEra" }
    public static var DESCRIPTION: String { "Generated by SwiftCardanoCore" }
    
    public var _payload: Data
    public var _type: String
    public var _description: String
    
    public var description: String {
        self.debugDescription
    }

    public var inputs: ListOrOrderedSet<TransactionInput>
    public var outputs: [TransactionOutput]
    public var fee: Coin
    public var ttl: Int?
    public var certificates: ListOrNonEmptyOrderedSet<Certificate>?
    public var withdrawals: Withdrawals?
    public var update: Update?
    public var auxiliaryDataHash: AuxiliaryDataHash?
    public var validityStart: Int?
    public var mint: MultiAsset?
    public var scriptDataHash: ScriptDataHash?
    public var collateral: ListOrNonEmptyOrderedSet<TransactionInput>?
    public var requiredSigners: ListOrNonEmptyOrderedSet<VerificationKeyHash>?
    public var networkId: Int?
    public var collateralReturn: TransactionOutput?
    public var totalCollateral: Coin?
    public var referenceInputs: ListOrNonEmptyOrderedSet<TransactionInput>?
    public var votingProcedures: VotingProcedures?
    public var proposalProcedures: ProposalProcedures?
    public var currentTreasuryAmount: Coin?
    public var treasuryDonation: PositiveCoin?
    
    enum CodingKeys: Int, CodingKey {
        case inputs = 0
        case outputs = 1
        case fee = 2
        case ttl = 3
        case certificates = 4
        case withdrawals = 5
        case update = 6
        case auxiliaryDataHash = 7
        case validityStart = 8
        case mint = 9
        case scriptDataHash = 11
        case collateral = 13
        case requiredSigners = 14
        case networkId = 15
        case collateralReturn = 16
        case totalCollateral = 17
        case referenceInputs = 18
        case votingProcedures = 19
        case proposalProcedures = 20
        case currentTreasuryAmount = 21
        case treasuryDonation = 22
        
        var stringValue: String {
            switch self {
            case .inputs: return "inputs"
            case .outputs: return "outputs"
            case .fee: return "fee"
            case .ttl: return "ttl"
            case .certificates: return "certificates"
            case .withdrawals: return "withdrawals"
            case .update: return "update"
            case .auxiliaryDataHash: return "auxiliaryDataHash"
            case .validityStart: return "validityStart"
            case .mint: return "mint"
            case .scriptDataHash: return "scriptDataHash"
            case .collateral: return "collateral"
            case .requiredSigners: return "requiredSigners"
            case .networkId: return "networkId"
            case .collateralReturn: return "collateralReturn"
            case .totalCollateral: return "totalCollateral"
            case .referenceInputs: return "referenceInputs"
            case .votingProcedures: return "votingProcedures"
            case .proposalProcedures: return "proposalProcedures"
            case .currentTreasuryAmount: return "currentTreasuryAmount"
            case .treasuryDonation: return "treasuryDonation"
            }
        }
    }
    
    public init(payload: Data, type: String?, description: String?) throws {
        self._payload = payload
        self._description = description ?? Self.DESCRIPTION
        self._type = type ?? Self.TYPE
        
        let cbor = try! CBORDecoder().decode(
            TransactionBody.self,
            from: payload
        )
        
        self.inputs = cbor.inputs
        self.outputs = cbor.outputs
        self.fee = cbor.fee
        self.ttl = cbor.ttl
        self.certificates = cbor.certificates
        self.withdrawals = cbor.withdrawals
        self.update = cbor.update
        self.auxiliaryDataHash = cbor.auxiliaryDataHash
        self.validityStart = cbor.validityStart
        self.mint = cbor.mint
        self.scriptDataHash = cbor.scriptDataHash
        self.collateral = cbor.collateral
        self.requiredSigners = cbor.requiredSigners
        self.networkId = cbor.networkId
        self.collateralReturn = cbor.collateralReturn
        self.totalCollateral = cbor.totalCollateral
        self.referenceInputs = cbor.referenceInputs
        self.votingProcedures = cbor.votingProcedures
        self.proposalProcedures = cbor.proposalProcedures
        self.currentTreasuryAmount = cbor.currentTreasuryAmount
        self.treasuryDonation = cbor.treasuryDonation
    }
    
    public init(
        inputs: ListOrOrderedSet<TransactionInput>,
        outputs: [TransactionOutput],
        fee: Coin,
        ttl: Int? = nil,
        certificates: ListOrNonEmptyOrderedSet<Certificate>? = nil,
        withdrawals: Withdrawals? = nil,
        update: Update? = nil,
        auxiliaryDataHash: AuxiliaryDataHash? = nil,
        validityStart: Int? = nil,
        mint: MultiAsset? = nil,
        scriptDataHash: ScriptDataHash? = nil,
        collateral: ListOrNonEmptyOrderedSet<TransactionInput>? = nil,
        requiredSigners: ListOrNonEmptyOrderedSet<VerificationKeyHash>? = nil,
        networkId: Int? = nil,
        collateralReturn: TransactionOutput? = nil,
        totalCollateral: Coin? = nil,
        referenceInputs: ListOrNonEmptyOrderedSet<TransactionInput>? = nil,
        votingProcedures: VotingProcedures? = nil,
        proposalProcedures: ProposalProcedures? = nil,
        currentTreasuryAmount: Coin? = nil,
        treasuryDonation: PositiveCoin? = nil
    ) {
        self.inputs = inputs
        self.outputs = outputs
        self.fee = fee
        self.ttl = ttl
        self.certificates = certificates
        self.withdrawals = withdrawals
        self.update = update
        self.auxiliaryDataHash = auxiliaryDataHash
        self.validityStart = validityStart
        self.mint = mint
        self.scriptDataHash = scriptDataHash
        self.collateral = collateral
        self.requiredSigners = requiredSigners
        self.networkId = networkId
        self.collateralReturn = collateralReturn
        self.totalCollateral = totalCollateral
        self.referenceInputs = referenceInputs
        self.votingProcedures = votingProcedures
        self.proposalProcedures = proposalProcedures
        self.currentTreasuryAmount = currentTreasuryAmount
        self.treasuryDonation = treasuryDonation
        
        // Build CBOR primitive ordered dictionary without using self
        var dictionary: OrderedDictionary<Primitive, Primitive> = [:]
        func key(_ key: CodingKeys) -> Primitive { .uint(UInt(key.rawValue)) }
        
        // Required fields
        try? { dictionary[key(.inputs)] = try inputs.toPrimitive() }()
        dictionary[key(.outputs)] = .list(try! outputs.map { try $0.toPrimitive() })
        dictionary[key(.fee)] = .uint(UInt(fee))
        
        // Optional fields
        if let ttl = ttl { dictionary[key(.ttl)] = .uint(UInt(ttl)) }
        if let certificates = certificates { dictionary[key(.certificates)] = try! certificates.toPrimitive() }
        if let withdrawals = withdrawals { dictionary[key(.withdrawals)] = try! withdrawals.toPrimitive() }
        if let update = update { dictionary[key(.update)] = try! update.toPrimitive() }
        if let auxiliaryDataHash = auxiliaryDataHash { dictionary[key(.auxiliaryDataHash)] = auxiliaryDataHash.toPrimitive() }
        if let validityStart = validityStart { dictionary[key(.validityStart)] = .uint(UInt(validityStart)) }
        if let mint = mint { dictionary[key(.mint)] = mint.toPrimitive() }
        if let scriptDataHash = scriptDataHash { dictionary[key(.scriptDataHash)] = scriptDataHash.toPrimitive() }
        if let collateral = collateral { dictionary[key(.collateral)] = try! collateral.toPrimitive() }
        if let requiredSigners = requiredSigners { dictionary[key(.requiredSigners)] = try! requiredSigners.toPrimitive() }
        if let networkId = networkId { dictionary[key(.networkId)] = .uint(UInt(networkId)) }
        if let collateralReturn = collateralReturn { dictionary[key(.collateralReturn)] = try! collateralReturn.toPrimitive() }
        if let totalCollateral = totalCollateral { dictionary[key(.totalCollateral)] = .uint(UInt(Int(totalCollateral))) }
        if let referenceInputs = referenceInputs { dictionary[key(.referenceInputs)] = try! referenceInputs.toPrimitive() }
        if let votingProcedures = votingProcedures { dictionary[key(.votingProcedures)] = try! votingProcedures.toPrimitive() }
        if let proposalProcedures = proposalProcedures { dictionary[key(.proposalProcedures)] = try! proposalProcedures.toPrimitive() }
        if let currentTreasuryAmount = currentTreasuryAmount { dictionary[key(.currentTreasuryAmount)] = .uint(UInt(currentTreasuryAmount)) }
        if let treasuryDonation = treasuryDonation { dictionary[key(.treasuryDonation)] = try! treasuryDonation.toPrimitive() }
        
        self._payload = try! CBOREncoder().encode(Primitive.orderedDict(dictionary))
        self._type = Self.TYPE
        self._description = Self.DESCRIPTION
    }

    public func validate() throws {
        // Check mint asset bounds - values should be within reasonable bounds for Cardano
        // Cardano uses 64-bit signed integers, but very large values can cause issues
        let maxMintAmount = 45_000_000_000_000_000 // Maximum reasonable mint amount for Cardano
        if let mint = mint, try mint
            .count(criteria: { _, _, v in abs(v) > maxMintAmount }) > 0 {
            throw CardanoCoreError.invalidArgument("Invalid mint amount: \(mint)")
        }
        
        // Validate all outputs
        for output in outputs {
            try output.validate()
        }
    }

    public var id: TransactionId {
        return TransactionId(payload: hash())
    }
    
    public func hash() -> Data {
        return try! Hash().blake2b(
            data: try self.toCBORData(),
            digestSize: TRANSACTION_HASH_SIZE,
            encoder: RawEncoder.self
        )
    }
    
    // MARK: - CBORSerializable
    
    public init(from primitive: Primitive) throws {
        var primitiveDict: OrderedDictionary<Primitive, Primitive> = [:]

        switch primitive {
        case let .dict(dict):
            primitiveDict.merge(dict) { (_, new) in new }
        case let .orderedDict(orderedDict):
            primitiveDict = orderedDict
        default:
            throw CardanoCoreError.deserializeError("Invalid TransactionBody type: \(primitive)")
        }

        func key(_ key: CodingKeys) -> Primitive { .uint(UInt(key.rawValue)) }

        // Required fields
        guard let inputsPrimitive = primitiveDict[key(.inputs)] else {
            throw CardanoCoreError.deserializeError("TransactionBody inputs are required")
        }
        let inputs = try ListOrOrderedSet<TransactionInput>(from: inputsPrimitive)

        guard let outputsPrimitive = primitiveDict[key(.outputs)] else {
            throw CardanoCoreError.deserializeError("TransactionBody outputs are required")
        }
        let outputs: [TransactionOutput]
        if case let .list(outputsList) = outputsPrimitive {
            outputs = try outputsList.map { try TransactionOutput(from: $0) }
        } else {
            throw CardanoCoreError.deserializeError("TransactionBody outputs must be an array")
        }

        guard let feePrimitive = primitiveDict[key(.fee)] else {
            throw CardanoCoreError.deserializeError("TransactionBody fee is required")
        }
        let fee: Coin
        if case let .uint(feeValue) = feePrimitive {
            fee = Coin(feeValue)
        } else {
            throw CardanoCoreError.deserializeError("TransactionBody fee must be an integer")
        }

        // Optional fields
        let ttl: Int?
        if let ttlPrimitive = primitiveDict[key(.ttl)], case let .uint(ttlValue) = ttlPrimitive { ttl = Int(ttlValue) } else { ttl = nil }

        let certificates: ListOrNonEmptyOrderedSet<Certificate>?
        if let certificatesPrimitive = primitiveDict[key(.certificates)] { certificates = try ListOrNonEmptyOrderedSet<Certificate>(from: certificatesPrimitive) } else { certificates = nil }

        let withdrawals: Withdrawals?
        if let withdrawalsPrimitive = primitiveDict[key(.withdrawals)] { withdrawals = try Withdrawals(from: withdrawalsPrimitive) } else { withdrawals = nil }

        let update: Update?
        if let updatePrimitive = primitiveDict[key(.update)] { update = try Update(from: updatePrimitive) } else { update = nil }

        let auxiliaryDataHash: AuxiliaryDataHash?
        if let auxiliaryDataHashPrimitive = primitiveDict[key(.auxiliaryDataHash)] { auxiliaryDataHash = try AuxiliaryDataHash(from: auxiliaryDataHashPrimitive) } else { auxiliaryDataHash = nil }

        let validityStart: Int?
        if let validityStartPrimitive = primitiveDict[key(.validityStart)], case let .uint(validityStartValue) = validityStartPrimitive { validityStart = Int(validityStartValue) } else { validityStart = nil }

        let mint: MultiAsset?
        if let mintPrimitive = primitiveDict[key(.mint)] { mint = try MultiAsset(from: mintPrimitive) } else { mint = nil }

        let scriptDataHash: ScriptDataHash?
        if let scriptDataHashPrimitive = primitiveDict[key(.scriptDataHash)] { scriptDataHash = try ScriptDataHash(from: scriptDataHashPrimitive) } else { scriptDataHash = nil }

        let collateral: ListOrNonEmptyOrderedSet<TransactionInput>?
        if let collateralPrimitive = primitiveDict[key(.collateral)] { collateral = try ListOrNonEmptyOrderedSet<TransactionInput>(from: collateralPrimitive) } else { collateral = nil }

        let requiredSigners: ListOrNonEmptyOrderedSet<VerificationKeyHash>?
        if let requiredSignersPrimitive = primitiveDict[key(.requiredSigners)] { requiredSigners = try ListOrNonEmptyOrderedSet<VerificationKeyHash>(from: requiredSignersPrimitive) } else { requiredSigners = nil }

        let networkId: Int?
        if let networkIdPrimitive = primitiveDict[key(.networkId)], case let .uint(networkIdValue) = networkIdPrimitive { networkId = Int(networkIdValue) } else { networkId = nil }

        let collateralReturn: TransactionOutput?
        if let collateralReturnPrimitive = primitiveDict[key(.collateralReturn)] { collateralReturn = try TransactionOutput(from: collateralReturnPrimitive) } else { collateralReturn = nil }

        let totalCollateral: Coin?
        if let totalCollateralPrimitive = primitiveDict[key(.totalCollateral)], case let .uint(totalCollateralValue) = totalCollateralPrimitive { totalCollateral = Coin(totalCollateralValue) } else { totalCollateral = nil }

        let referenceInputs: ListOrNonEmptyOrderedSet<TransactionInput>?
        if let referenceInputsPrimitive = primitiveDict[key(.referenceInputs)] { referenceInputs = try ListOrNonEmptyOrderedSet<TransactionInput>(from: referenceInputsPrimitive) } else { referenceInputs = nil }

        let votingProcedures: VotingProcedures?
        if let votingProceduresPrimitive = primitiveDict[key(.votingProcedures)] { votingProcedures = try VotingProcedures(from: votingProceduresPrimitive) } else { votingProcedures = nil }

        let proposalProcedures: ProposalProcedures?
        if let proposalProceduresPrimitive = primitiveDict[key(.proposalProcedures)] { proposalProcedures = try ProposalProcedures(from: proposalProceduresPrimitive) } else { proposalProcedures = nil }

        let currentTreasuryAmount: Coin?
        if let currentTreasuryAmountPrimitive = primitiveDict[key(.currentTreasuryAmount)], case let .uint(currentTreasuryAmountValue) = currentTreasuryAmountPrimitive { currentTreasuryAmount = Coin(currentTreasuryAmountValue) } else { currentTreasuryAmount = nil }

        let treasuryDonation: PositiveCoin?
        if let treasuryDonationPrimitive = primitiveDict[key(.treasuryDonation)] { treasuryDonation = try PositiveCoin(from: treasuryDonationPrimitive) } else { treasuryDonation = nil }

        self.init(
            inputs: inputs,
            outputs: outputs,
            fee: fee,
            ttl: ttl,
            certificates: certificates,
            withdrawals: withdrawals,
            update: update,
            auxiliaryDataHash: auxiliaryDataHash,
            validityStart: validityStart,
            mint: mint,
            scriptDataHash: scriptDataHash,
            collateral: collateral,
            requiredSigners: requiredSigners,
            networkId: networkId,
            collateralReturn: collateralReturn,
            totalCollateral: totalCollateral,
            referenceInputs: referenceInputs,
            votingProcedures: votingProcedures,
            proposalProcedures: proposalProcedures,
            currentTreasuryAmount: currentTreasuryAmount,
            treasuryDonation: treasuryDonation
        )
    }
    
    public func toPrimitive() throws -> Primitive {
        var dictionary: OrderedDictionary<Primitive, Primitive> = [:]
        
        func key(_ key: CodingKeys) -> Primitive {
            return .uint(UInt(key.rawValue))
        }
        
        // Required fields
        dictionary[key(CodingKeys.inputs)] = try inputs.toPrimitive()
        dictionary[key(CodingKeys.outputs)] =
            .list(try outputs.map { try $0.toPrimitive() })
        dictionary[key(CodingKeys.fee)] = .uint(UInt(fee))
        
        // Optional fields
        if let ttl = ttl {
            dictionary[key(CodingKeys.ttl)] = .uint(UInt(ttl))
        }
        if let certificates = certificates {
            dictionary[key(CodingKeys.certificates)] = try certificates.toPrimitive()
        }
        if let withdrawals = withdrawals {
            dictionary[key(CodingKeys.withdrawals)] = try withdrawals.toPrimitive()
        }
        if let update = update {
            dictionary[key(CodingKeys.update)] = try update.toPrimitive()
        }
        if let auxiliaryDataHash = auxiliaryDataHash {
            dictionary[key(CodingKeys.auxiliaryDataHash)] = auxiliaryDataHash.toPrimitive()
        }
        if let validityStart = validityStart {
            dictionary[key(CodingKeys.validityStart)] = 
                .uint(UInt(validityStart))
        }
        if let mint = mint {
            dictionary[key(CodingKeys.mint)] = mint.toPrimitive()
        }
        if let scriptDataHash = scriptDataHash {
            dictionary[key(CodingKeys.scriptDataHash)] = scriptDataHash.toPrimitive()
        }
        if let collateral = collateral {
            dictionary[key(CodingKeys.collateral)] = try collateral.toPrimitive()
        }
        if let requiredSigners = requiredSigners {
            dictionary[key(CodingKeys.requiredSigners)] = try requiredSigners.toPrimitive()
        }
        if let networkId = networkId {
            dictionary[key(CodingKeys.networkId)] = .uint(UInt(networkId))
        }
        if let collateralReturn = collateralReturn {
            dictionary[key(CodingKeys.collateralReturn)] = try collateralReturn.toPrimitive()
        }
        if let totalCollateral = totalCollateral {
            dictionary[key(CodingKeys.totalCollateral)] = 
                .uint(UInt(Int(totalCollateral)))
        }
        if let referenceInputs = referenceInputs {
            dictionary[key(CodingKeys.referenceInputs)] = try referenceInputs.toPrimitive()
        }
        if let votingProcedures = votingProcedures {
            dictionary[key(CodingKeys.votingProcedures)] = try votingProcedures.toPrimitive()
        }
        if let proposalProcedures = proposalProcedures {
            dictionary[key(CodingKeys.proposalProcedures)] = try proposalProcedures.toPrimitive()
        }
        if let currentTreasuryAmount = currentTreasuryAmount {
            dictionary[key(CodingKeys.currentTreasuryAmount)] = 
                .uint(UInt(currentTreasuryAmount))
        }
        if let treasuryDonation = treasuryDonation {
            dictionary[key(CodingKeys.treasuryDonation)] = try treasuryDonation.toPrimitive()
        }
        
        return .orderedDict(dictionary)
    }
    
    // MARK: - JSONSerializable
    
    public static func fromDict(_ dict: Primitive) throws -> TransactionBody {
        guard case let .orderedDict(orderedDict) = dict else {
            throw CardanoCoreError.deserializeError("Invalid TransactionBody dict format")
        }
        // Required fields
        guard let inputsPrimitive = orderedDict[.string(CodingKeys.inputs.stringValue)] else {
            throw CardanoCoreError.deserializeError("Missing inputs in TransactionBody")
        }
        let inputs = try ListOrOrderedSet<TransactionInput>.fromDict(inputsPrimitive)
        
        guard let outputsPrimitive = orderedDict[.string(CodingKeys.outputs.stringValue)],
              case let .list(outputsList) = outputsPrimitive else {
            throw CardanoCoreError.deserializeError("Missing or invalid outputs in TransactionBody")
        }
        let outputs = try outputsList.map { try TransactionOutput.fromDict($0) }
        
        guard let feePrimitive = orderedDict[.string(CodingKeys.fee.stringValue)],
              case let .int(feeValue) = feePrimitive else {
            throw CardanoCoreError.deserializeError("Missing or invalid fee in TransactionBody")
        }
        let fee = Coin(feeValue)
        
        // Optional fields
        var ttl: Int? = nil
        if let ttlPrimitive = orderedDict[.string(CodingKeys.ttl.stringValue)],
           case let .int(ttlValue) = ttlPrimitive {
            ttl = ttlValue
        }
        
        var certificates: ListOrNonEmptyOrderedSet<Certificate>? = nil
        if let certificatesPrimitive = orderedDict[.string(CodingKeys.certificates.stringValue)] {
            certificates = try ListOrNonEmptyOrderedSet<Certificate>.fromDict(certificatesPrimitive)
        }
        
        var withdrawals: Withdrawals? = nil
        if let withdrawalsPrimitive = orderedDict[.string(CodingKeys.withdrawals.stringValue)] {
            withdrawals = try Withdrawals.fromDict(withdrawalsPrimitive)
        }
        
        var update: Update? = nil
        if let updatePrimitive = orderedDict[.string(CodingKeys.update.stringValue)] {
            update = try Update.fromDict(updatePrimitive)
        }
        
        var auxiliaryDataHash: AuxiliaryDataHash? = nil
        if let auxiliaryDataHashPrimitive = orderedDict[.string(CodingKeys.auxiliaryDataHash.stringValue)] {
            auxiliaryDataHash = try AuxiliaryDataHash(from: auxiliaryDataHashPrimitive)
        }
        
        var validityStart: Int? = nil
        if let validityStartPrimitive = orderedDict[.string(CodingKeys.validityStart.stringValue)],
           case let .int(validityStartValue) = validityStartPrimitive {
            validityStart = validityStartValue
        }
        
        var mint: MultiAsset? = nil
        if let mintPrimitive = orderedDict[.string(CodingKeys.mint.stringValue)] {
            mint = try MultiAsset.fromDict(mintPrimitive)
        }
        
        var scriptDataHash: ScriptDataHash? = nil
        if let scriptDataHashPrimitive = orderedDict[.string(CodingKeys.scriptDataHash.stringValue)] {
            scriptDataHash = try ScriptDataHash.fromDict(scriptDataHashPrimitive)
        }
        
        var collateral: ListOrNonEmptyOrderedSet<TransactionInput>? = nil
        if let collateralPrimitive = orderedDict[.string(CodingKeys.collateral.stringValue)] {
            collateral = try ListOrNonEmptyOrderedSet<TransactionInput>.fromDict(collateralPrimitive)
        }
        
        var requiredSigners: ListOrNonEmptyOrderedSet<VerificationKeyHash>? = nil
        if let requiredSignersPrimitive = orderedDict[.string(CodingKeys.requiredSigners.stringValue)] {
            requiredSigners = try ListOrNonEmptyOrderedSet<VerificationKeyHash>.fromDict(requiredSignersPrimitive)
        }
        
        var networkId: Int? = nil
        if let networkIdPrimitive = orderedDict[.string(CodingKeys.networkId.stringValue)],
           case let .int(networkIdValue) = networkIdPrimitive {
            networkId = networkIdValue
        }
        
        var collateralReturn: TransactionOutput? = nil
        if let collateralReturnPrimitive = orderedDict[.string(CodingKeys.collateralReturn.stringValue)] {
            collateralReturn = try TransactionOutput.fromDict(collateralReturnPrimitive)
        }
        
        var totalCollateral: Coin? = nil
        if let totalCollateralPrimitive = orderedDict[.string(CodingKeys.totalCollateral.stringValue)],
           case let .int(totalCollateralValue) = totalCollateralPrimitive {
            totalCollateral = Coin(totalCollateralValue)
        }
        
        var referenceInputs: ListOrNonEmptyOrderedSet<TransactionInput>? = nil
        if let referenceInputsPrimitive = orderedDict[.string(CodingKeys.referenceInputs.stringValue)] {
            referenceInputs = try ListOrNonEmptyOrderedSet<TransactionInput>.fromDict(referenceInputsPrimitive)
        }
        
        var votingProcedures: VotingProcedures? = nil
        if let votingProceduresPrimitive = orderedDict[.string(CodingKeys.votingProcedures.stringValue)] {
            votingProcedures = try VotingProcedures.fromDict(votingProceduresPrimitive)
        }
        
        var proposalProcedures: ProposalProcedures? = nil
        if let proposalProceduresPrimitive = orderedDict[.string(CodingKeys.proposalProcedures.stringValue)] {
            proposalProcedures = try ProposalProcedures.fromDict(proposalProceduresPrimitive)
        }
        
        var currentTreasuryAmount: Coin? = nil
        if let currentTreasuryAmountPrimitive = orderedDict[.string(CodingKeys.currentTreasuryAmount.stringValue)],
           case let .int(currentTreasuryAmountValue) = currentTreasuryAmountPrimitive {
            currentTreasuryAmount = Coin(currentTreasuryAmountValue)
        }
        
        var treasuryDonation: PositiveCoin? = nil
        if let treasuryDonationPrimitive = orderedDict[.string(CodingKeys.treasuryDonation.stringValue)] {
            treasuryDonation = try PositiveCoin.fromDict(treasuryDonationPrimitive)
        }
        
        return TransactionBody(
            inputs: inputs,
            outputs: outputs,
            fee: fee,
            ttl: ttl,
            certificates: certificates,
            withdrawals: withdrawals,
            update: update,
            auxiliaryDataHash: auxiliaryDataHash,
            validityStart: validityStart,
            mint: mint,
            scriptDataHash: scriptDataHash,
            collateral: collateral,
            requiredSigners: requiredSigners,
            networkId: networkId,
            collateralReturn: collateralReturn,
            totalCollateral: totalCollateral,
            referenceInputs: referenceInputs,
            votingProcedures: votingProcedures,
            proposalProcedures: proposalProcedures,
            currentTreasuryAmount: currentTreasuryAmount,
            treasuryDonation: treasuryDonation
        )
    }
    
    public func toDict() throws -> Primitive {
        var dict = OrderedDictionary<Primitive, Primitive>()
        
        // Helper to convert ListOrOrderedSet to list of primitives
        func listOrSetToList<T: CBORSerializable>(_ value: ListOrOrderedSet<T>) throws -> Primitive {
            switch value {
                case .list(let array):
                    return .list(try array.map { try $0.toPrimitive() })
                case .orderedSet(let set):
                    return .list(try set.elements.map { try $0.toPrimitive() })
            }
        }
        
        // Helper to convert ListOrNonEmptyOrderedSet to list of primitives
        func listOrNonEmptySetToList<T: CBORSerializable>(_ value: ListOrNonEmptyOrderedSet<T>) throws -> Primitive {
            switch value {
                case .list(let array):
                    return .list(try array.map { try $0.toPrimitive() })
                case .nonEmptyOrderedSet(let set):
                    return .list(try set.elements.map { try $0.toPrimitive() })
            }
        }
        
        // Required fields
        dict[.string(CodingKeys.inputs.stringValue)] = try inputs.toDict()
        dict[.string(CodingKeys.outputs.stringValue)] = .list(try outputs.map( { try $0.toDict() } ))
        dict[.string(CodingKeys.fee.stringValue)] = .int(Int(fee))
        
        // Optional fields
        if let ttl = ttl {
            dict[.string(CodingKeys.ttl.stringValue)] = .int(ttl)
        }
        if let certificates = certificates {
            dict[.string(CodingKeys.certificates.stringValue)] = try certificates.toDict()
        }
        if let withdrawals = withdrawals {
            dict[.string(CodingKeys.withdrawals.stringValue)] = try withdrawals.toDict()
        }
        if let update = update {
            dict[.string(CodingKeys.update.stringValue)] = try update.toDict()
        }
        if let auxiliaryDataHash = auxiliaryDataHash {
            dict[.string(CodingKeys.auxiliaryDataHash.stringValue)] = .string(auxiliaryDataHash.payload.toHex)
        }
        if let validityStart = validityStart {
            dict[.string(CodingKeys.validityStart.stringValue)] = .int(validityStart)
        }
        if let mint = mint {
            dict[.string(CodingKeys.mint.stringValue)] = try mint.toDict()
        }
        if let scriptDataHash = scriptDataHash {
            dict[.string(CodingKeys.scriptDataHash.stringValue)] = try scriptDataHash.toDict()
        }
        if let collateral = collateral {
            dict[.string(CodingKeys.collateral.stringValue)] = try collateral.toDict()
        }
        if let requiredSigners = requiredSigners {
            dict[.string(CodingKeys.requiredSigners.stringValue)] = try requiredSigners.toDict()
        }
        if let networkId = networkId {
            dict[.string(CodingKeys.networkId.stringValue)] = .int(networkId)
        }
        if let collateralReturn = collateralReturn {
            dict[.string(CodingKeys.collateralReturn.stringValue)] = try collateralReturn.toDict()
        }
        if let totalCollateral = totalCollateral {
            dict[.string(CodingKeys.totalCollateral.stringValue)] = .int(Int(totalCollateral))
        }
        if let referenceInputs = referenceInputs {
            dict[.string(CodingKeys.referenceInputs.stringValue)] = try referenceInputs.toDict()
        }
        if let votingProcedures = votingProcedures {
            dict[.string(CodingKeys.votingProcedures.stringValue)] = try votingProcedures.toDict()
        }
        if let proposalProcedures = proposalProcedures {
            dict[.string(CodingKeys.proposalProcedures.stringValue)] = try proposalProcedures.toDict()
        }
        if let currentTreasuryAmount = currentTreasuryAmount {
            dict[.string(CodingKeys.currentTreasuryAmount.stringValue)] = .int(Int(currentTreasuryAmount))
        }
        if let treasuryDonation = treasuryDonation {
            dict[.string(CodingKeys.treasuryDonation.stringValue)] = try treasuryDonation.toDict()
        }
        
        return .orderedDict(dict)
    }
    
    // MARK: - Equatable
    
    public static func == (lhs: TransactionBody, rhs: TransactionBody) -> Bool {
        return lhs.inputs == rhs.inputs &&
        lhs.outputs == rhs.outputs &&
        lhs.fee == rhs.fee &&
        lhs.ttl == rhs.ttl &&
        lhs.certificates == rhs.certificates &&
        lhs.withdrawals == rhs.withdrawals &&
        lhs.update == rhs.update &&
        lhs.auxiliaryDataHash == rhs.auxiliaryDataHash &&
        lhs.validityStart == rhs.validityStart &&
        lhs.mint == rhs.mint &&
        lhs.scriptDataHash == rhs.scriptDataHash &&
        lhs.collateral == rhs.collateral &&
        lhs.requiredSigners == rhs.requiredSigners &&
        lhs.networkId == rhs.networkId &&
        lhs.collateralReturn == rhs.collateralReturn &&
        lhs.totalCollateral == rhs.totalCollateral &&
        lhs.referenceInputs == rhs.referenceInputs &&
        lhs.votingProcedures == rhs.votingProcedures &&
        lhs.proposalProcedures == rhs.proposalProcedures &&
        lhs.currentTreasuryAmount == rhs.currentTreasuryAmount &&
        lhs.treasuryDonation == rhs.treasuryDonation
    }
}
