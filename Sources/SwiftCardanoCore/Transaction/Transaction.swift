import Foundation
import PotentCBOR
import OrderedCollections

public struct Transaction: Serializable, TextEnvelopable {
    public static var TYPE: String { "Unwitnessed Tx ConwayEra" }
    public static var DESCRIPTION: String { "Generated by SwiftCardanoCore" }
    
    public var _payload: Data
    public var _type: String
    public var _description: String
    
    public var description: String {
        self.debugDescription
    }
    
    public var transactionBody: TransactionBody
    public var transactionWitnessSet: TransactionWitnessSet
    public var valid: Bool = true
    public var auxiliaryData: AuxiliaryData? = nil
    
    enum CodingKeys: String, CodingKey {
        case transactionBody
        case transactionWitnessSet
        case valid
        case auxiliaryData
    }
    
    public var id: TransactionId? {
        return transactionBody.id
    }
    
    public init(
        transactionBody: TransactionBody,
        transactionWitnessSet: TransactionWitnessSet,
        valid: Bool = true,
        auxiliaryData: AuxiliaryData? = nil
    ) {
        self.transactionBody = transactionBody
        self.transactionWitnessSet = transactionWitnessSet
        self.valid = valid
        self.auxiliaryData = auxiliaryData
        
        self._payload =  try! CBORSerialization.data(from:
                .array(
                    [
                        try! CBOREncoder().encode(transactionBody).toCBOR,
                        try! CBOREncoder().encode(transactionWitnessSet).toCBOR,
                        try! CBOREncoder().encode(valid).toCBOR,
                        try! CBOREncoder().encode(auxiliaryData).toCBOR,
                    ]
                )
        )
        self._type = transactionWitnessSet
            .isEmpty() ? Self.TYPE : Self.TYPE
            .replacingOccurrences(of: "Unwitnessed ", with: "")
        self._description = Self.DESCRIPTION
    }
    
    public init(payload: Data, type: String?, description: String?) {
        self._payload = payload
        self._description = description ?? Self.DESCRIPTION
        
        let cbor = try! CBORDecoder().decode(Transaction.self, from: payload)
        
        self.transactionBody = cbor.transactionBody
        self.transactionWitnessSet = cbor.transactionWitnessSet
        self.valid = cbor.valid
        self.auxiliaryData = cbor.auxiliaryData
        
        self._type = self.transactionWitnessSet
            .isEmpty() ? Self.TYPE : Self.TYPE
            .replacingOccurrences(of: "Unwitnessed ", with: "")
    }
    
    // MARK: - CBORSerializable
    
    public init(from primitive: Primitive) throws {
        guard case let .list(elements) = primitive else {
            throw CardanoCoreError.deserializeError("Invalid Transaction primitive: \(primitive)")
        }
        
        guard elements.count >= 3 else {
            throw CardanoCoreError.deserializeError("Transaction requires at least 3 elements")
        }
        
        // transactionBody (required)
        let transactionBody = try TransactionBody(from: elements[0])
        
        // transactionWitnessSet (required) - may be wrapped in a CBOR tag
        let transactionWitnessSet: TransactionWitnessSet
        if case let .cborTag(tagged) = elements[1] {
            // Witness set is wrapped in a CBOR tag, extract the value
            transactionWitnessSet = try TransactionWitnessSet(from: tagged.value)
        } else {
            // Witness set is not tagged
            transactionWitnessSet = try TransactionWitnessSet(from: elements[1])
        }
        
        // valid (required)
        guard case let .bool(valid) = elements[2] else {
            throw CardanoCoreError.deserializeError("Invalid valid field in Transaction")
        }
        
        // auxiliaryData (optional)
        var auxiliaryData: AuxiliaryData? = nil
        if elements.count > 3 {
            if case .null = elements[3] {
                auxiliaryData = nil
            } else {
                auxiliaryData = try AuxiliaryData(from: elements[3])
            }
        }
        
        self.init(
            transactionBody: transactionBody,
            transactionWitnessSet: transactionWitnessSet,
            valid: valid,
            auxiliaryData: auxiliaryData
        )
    }
    
    
    public func toPrimitive() throws -> Primitive {
        return .list([
            try transactionBody.toPrimitive(),
            try transactionWitnessSet.toPrimitive(),
            .bool(valid),
            try auxiliaryData?.toPrimitive() ?? .null
        ])
    }
    
    // MARK: - JSONSerializable
    
    public static func fromDict(_ dict: Primitive) throws -> Transaction {
        guard case let .orderedDict(dictValue) = dict else {
            throw CardanoCoreError.deserializeError("Invalid Transaction dict")
        }
        // Required fields
        guard let transactionBodyPrimitive = dictValue[.string(CodingKeys.transactionBody.rawValue)] else {
            throw CardanoCoreError.deserializeError("Missing transactionBody in Transaction")
        }
        let transactionBody = try TransactionBody.fromDict(transactionBodyPrimitive)
        
        guard let transactionWitnessSetPrimitive = dictValue[.string(CodingKeys.transactionWitnessSet.rawValue)] else {
            throw CardanoCoreError.deserializeError("Missing transactionWitnessSet in Transaction")
        }
        let transactionWitnessSet = try TransactionWitnessSet.fromDict(transactionWitnessSetPrimitive)
        
        guard let validPrimitive = dictValue[.string(CodingKeys.valid.rawValue)] else {
            throw CardanoCoreError.deserializeError("Missing valid field in Transaction")
        }
        
        let valid: Bool
        switch validPrimitive {
        case .bool(let boolValue):
            valid = boolValue
        case .int(let intValue):
            valid = intValue != 0
        case .uint(let uintValue):
            valid = uintValue != 0
        default:
            throw CardanoCoreError.deserializeError("Invalid valid field type in Transaction: \(validPrimitive)")
        }
        
        // Optional field
        var auxiliaryData: AuxiliaryData? = nil
        if let auxiliaryDataPrimitive = dictValue[.string(CodingKeys.auxiliaryData.rawValue)] {
            if case .null = auxiliaryDataPrimitive {
                auxiliaryData = nil
            } else {
                auxiliaryData = try AuxiliaryData.fromDict(auxiliaryDataPrimitive)
            }
        }
        
        return Transaction(
            transactionBody: transactionBody,
            transactionWitnessSet: transactionWitnessSet,
            valid: valid,
            auxiliaryData: auxiliaryData
        )
    }
    
    public func toDict() throws -> Primitive {
        var dict = OrderedDictionary<Primitive, Primitive>()
        
        dict[.string(CodingKeys.transactionBody.rawValue)] = try transactionBody.toDict()
        dict[.string(CodingKeys.transactionWitnessSet.rawValue)] = try transactionWitnessSet.toDict()
        dict[.string(CodingKeys.valid.rawValue)] = .bool(valid)
        
        if let auxiliaryData = auxiliaryData {
            dict[.string(CodingKeys.auxiliaryData.rawValue)] = try auxiliaryData.toDict()
        } else {
            dict[.string(CodingKeys.auxiliaryData.rawValue)] = .null
        }
        
        return .orderedDict(dict)
    }
    
    
    /// Serialize to JSON.
    ///
    /// The json output has three fields: "type", "description", and "cborHex".
    /// - Returns: JSON representation
    public func toTextEnvelope() throws -> String? {
        let updatedType = transactionWitnessSet.isEmpty() ? Self.TYPE : Self.TYPE
            .replacingOccurrences(of: "Unwitnessed ", with: "")
        
        let jsonString = """
        {
            "type": "\(updatedType)",
            "description": "\(self._description)",
            "cborHex": "\(try self.toCBORHex())"
        }
        """
        return jsonString
    }
    
    // MARK: - Equatable
    
    public static func == (lhs: Self, rhs: Self) -> Bool {
        return lhs.transactionBody == rhs.transactionBody &&
        lhs.transactionWitnessSet == rhs.transactionWitnessSet &&
        lhs.valid == rhs.valid &&
        lhs.auxiliaryData == rhs.auxiliaryData
    }
    
}
