import Foundation
import PotentCBOR

public struct Transaction<T: CBORSerializable & Hashable>: CBORSerializable, PayloadJSONSerializable, Equatable, Hashable {
    public static var TYPE: String { "Unwitnessed Tx ConwayEra" }
    public static var DESCRIPTION: String { "Generated by SwiftCardanoCore" }

    public var _payload: Data
    public var _type: String
    public var _description: String

    public var transactionBody: TransactionBody
    public var transactionWitnessSet: TransactionWitnessSet<T>
    public var valid: Bool = true
    public var auxiliaryData: AuxiliaryData? = nil

    public var id: TransactionId? {
        return transactionBody.id
    }
    
    public init(
        transactionBody: TransactionBody,
        transactionWitnessSet: TransactionWitnessSet<T>,
        valid: Bool = true,
        auxiliaryData: AuxiliaryData? = nil
    ) {
        self.transactionBody = transactionBody
        self.transactionWitnessSet = transactionWitnessSet
        self.valid = valid
        self.auxiliaryData = auxiliaryData
        
        self._payload =  try! CBORSerialization.data(from:
                .array(
                    [
                        try! CBOREncoder().encode(transactionBody).toCBOR,
                        try! CBOREncoder().encode(transactionWitnessSet).toCBOR,
                        try! CBOREncoder().encode(valid).toCBOR,
                        try! CBOREncoder().encode(auxiliaryData).toCBOR,
                    ]
                )
        )
        self._type = transactionWitnessSet
            .isEmpty() ? Self.TYPE : Self.TYPE
            .replacingOccurrences(of: "Unwitnessed", with: "Witnessed")
        self._description = Self.DESCRIPTION
    }
    
    public init(payload: Data, type: String?, description: String?) {
        self._payload = payload
        self._description = description ?? Self.DESCRIPTION
        
        let cbor = try! CBORDecoder().decode(Transaction.self, from: payload)
        
        self.transactionBody = cbor.transactionBody
        self.transactionWitnessSet = cbor.transactionWitnessSet
        self.valid = cbor.valid
        self.auxiliaryData = cbor.auxiliaryData
        
        self._type = self.transactionWitnessSet
            .isEmpty() ? Self.TYPE : Self.TYPE
            .replacingOccurrences(of: "Unwitnessed", with: "Witnessed")
    }
    
    public init(from primitive: Primitive) throws {
        guard case let .list(elements) = primitive else {
            throw CardanoCoreError.deserializeError("Invalid Transaction primitive")
        }
        
        guard elements.count >= 3 else {
            throw CardanoCoreError.deserializeError("Transaction requires at least 3 elements")
        }
        
        // transactionBody (required)
        let transactionBody = try TransactionBody(from: elements[0])
        
        // transactionWitnessSet (required)
        let transactionWitnessSet = try TransactionWitnessSet<T>(from: elements[1])
        
        // valid (required)
        guard case let .bool(valid) = elements[2] else {
            throw CardanoCoreError.deserializeError("Invalid valid field in Transaction")
        }
        
        // auxiliaryData (optional)
        var auxiliaryData: AuxiliaryData? = nil
        if elements.count > 3 {
            if case .null = elements[3] {
                auxiliaryData = nil
            } else {
                auxiliaryData = try AuxiliaryData(from: elements[3])
            }
        }
        
        self.init(
            transactionBody: transactionBody,
            transactionWitnessSet: transactionWitnessSet,
            valid: valid,
            auxiliaryData: auxiliaryData
        )
    }

    
    public func toPrimitive() throws -> Primitive {
        return .list([
            try transactionBody.toPrimitive(),
            try transactionWitnessSet.toPrimitive(),
            .bool(valid),
            try auxiliaryData?.toPrimitive() ?? .null
        ])
    }
    
    /// Serialize to JSON.
    ///
    /// The json output has three fields: "type", "description", and "cborHex".
    /// - Returns: JSON representation
    func toJSON() throws -> String? {
        let jsonString = """
        {
            "type": "\(type)",
            "description": "\(description)",
            "cborHex": "\(payload.toHex)"
        }
        """
        return jsonString
    }
    
    public static func == (lhs: Self, rhs: Self) -> Bool {
        return lhs.transactionBody == rhs.transactionBody &&
                lhs.transactionWitnessSet == rhs.transactionWitnessSet &&
                lhs.valid == rhs.valid &&
                lhs.auxiliaryData == rhs.auxiliaryData
    }
    
}
